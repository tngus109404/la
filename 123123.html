<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>로스트아크 젬 인식 (타이틀 색상+OCR, 드래그 ROI, 색상마스킹)</title>
  <style>
    :root { --bg:#0b1016; --panel:#121a24; --ink:#e9f1ff; --muted:#8ea3b6; --accent:#6aa6ff; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple SD Gothic Neo,Noto Sans KR,"맑은 고딕",sans-serif}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
    h1{font-size:22px;margin:0 0 8px}
    small{color:var(--muted)}
    .grid{display:grid;gap:12px}
    @media(min-width:920px){.grid{grid-template-columns: 1.1fr 1fr}}
    .card{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="number"], select{background:#0c141d;border:1px solid rgba(255,255,255,.08);border-radius:8px;color:var(--ink);padding:8px}
    button{background:var(--accent);color:#02152c;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;color:var(--ink);border:1px solid rgba(255,255,255,.18)}
    .pill{display:inline-flex;gap:8px;align-items:center;background:#0e1620;border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:6px 10px;color:var(--muted)}
    .kv{display:grid;grid-template-columns: 120px 1fr;gap:6px;font-size:14px}
    .kv b{color:var(--muted)}
    canvas, video{max-width:100%;background:#0c141d;border-radius:12px;border:1px dashed rgba(255,255,255,.1)}
    .section-title{font-size:13px;color:var(--muted);margin:6px 0 8px}
    .hr{height:1px;background:rgba(255,255,255,.07);margin:10px -14px}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#162234;color:#9ec0ff;font-size:12px}
  </style>
  <!-- OpenCV.js & Tesseract.js (CDN) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>아크 그리드 젬 인식 <span class="tag">웹</span></h1>
    <small>타이틀(예: “질서의 젬 : 안정”) 영역을 드래그로 지정 → 색상 마스킹 후 OCR → 퍼지 매칭으로 젬 종류 인식, 주색상으로 등급(고급/희귀/영웅) 판정. (HTTPS 또는 http://localhost 필요)</small>

    <div class="grid" style="margin-top:14px">
      <!-- LEFT -->
      <div class="card">
        <div class="row">
          <button id="btnStart">화면 캡처 허용</button>
          <button id="btnGrab" class="ghost">한 프레임 분석</button>
          <button id="btnLoop" class="ghost">연속 감지 시작</button>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="pill">상태: <span id="status">대기</span></span>
          <span class="pill">OpenCV: <span id="cvState">로딩중</span></span>
          <span class="pill">Tesseract: <span id="ocrState">준비</span></span>
        </div>

        <div class="hr"></div>
        <div class="row">
          <div style="flex:1 1 320px">
            <div class="section-title">라이브 미리보기</div>
            <video id="video" autoplay playsinline muted></video>
          </div>
          <div style="flex:1 1 320px">
            <div class="section-title">분석 캔버스 (여기서 드래그)</div>
            <canvas id="canvas"></canvas>
          </div>
        </div>

        <div class="hr"></div>
        <div class="row">
          <div>
            <div class="section-title">ROI · 타이틀 텍스트/색상(%)</div>
            <div class="row">
              <label>left <input id="gradeL" type="number" value="46" min="0" max="100" style="width:80px">%</label>
              <label>top <input id="gradeT" type="number" value="14" min="0" max="100" style="width:80px">%</label>
              <label>right <input id="gradeR" type="number" value="54" min="0" max="100" style="width:80px">%</label>
              <label>bottom <input id="gradeB" type="number" value="20" min="0" max="100" style="width:80px">%</label>
            </div>
          </div>
          <div>
            <div class="section-title">ROI · (옵션) 젬 아이콘(%)</div>
            <div class="row">
              <label>left <input id="gemL" type="number" value="44" min="0" max="100" style="width:80px">%</label>
              <label>top <input id="gemT" type="number" value="24" min="0" max="100" style="width:80px">%</label>
              <label>right <input id="gemR" type="number" value="56" min="0" max="100" style="width:80px">%</label>
              <label>bottom <input id="gemB" type="number" value="38" min="0" max="100" style="width:80px">%</label>
            </div>
          </div>
        </div>

        <!-- 드래그 대상 선택 -->
        <div class="row" style="margin-top:8px">
          <label>드래그 대상
            <select id="roiTarget">
              <option value="grade">타이틀 ROI (파란 박스)</option>
              <option value="gem">젬 아이콘 ROI (초록 박스)</option>
            </select>
          </label>
          <small style="color:#8ea3b6">캔버스 위에서 드래그 → 선택한 ROI가 갱신됩니다</small>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="section-title">결과</div>
        <div class="kv">
          <b>등급</b><div id="outGrade">-</div>
          <b>젬 종류</b><div id="outGem">-</div>
          <b>디버그</b><div id="outDbg" style="white-space:pre-wrap;color:var(--muted)">-</div>
        </div>
      </div>
    </div>
  </div>

<script>
  // ---------- 상태 / 헬퍼 ----------
  const $ = (sel)=>document.querySelector(sel);
  const els = {
    btnStart: $('#btnStart'), btnGrab: $('#btnGrab'), btnLoop: $('#btnLoop'),
    video: $('#video'), canvas: $('#canvas'), status: $('#status'),
    gradeL: $('#gradeL'), gradeT: $('#gradeT'), gradeR: $('#gradeR'), gradeB: $('#gradeB'),
    gemL: $('#gemL'), gemT: $('#gemT'), gemR: $('#gemR'), gemB: $('#gemB'),
    outGrade: $('#outGrade'), outGem: $('#outGem'), outDbg: $('#outDbg'),
    cvState: $('#cvState'), ocrState: $('#ocrState'),
    roiTarget: $('#roiTarget'),
  };

  let stream = null, loopOn = false, cvReady = false;
  function setStatus(s){ els.status.textContent = s }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)) }

  function drawFrame(){
    const v = els.video;
    const c = els.canvas, ctx = c.getContext('2d');
    if(!v.videoWidth) return null;
    c.width = v.videoWidth; c.height = v.videoHeight;
    ctx.drawImage(v,0,0,c.width,c.height);
    return ctx.getImageData(0,0,c.width,c.height);
  }
  function pct2rect(w,h,l,t,r,b){
    const x1 = Math.round(w*(l/100)), y1 = Math.round(h*(t/100));
    const x2 = Math.round(w*(r/100)), y2 = Math.round(h*(b/100));
    return {x:x1, y:y1, w:Math.max(1,x2-x1), h:Math.max(1,y2-y1)};
  }
  function cropImageData(imgData, rect){
    const {x,y,w,h} = rect;
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d'); ctx.putImageData(imgData, -x, -y);
    return c;
  }

  // ---------- OCR (한글 우선) ----------
  let ocrWorker = null;
  async function ensureOCR(lang = 'kor'){
    if (ocrWorker) return ocrWorker;
    els.ocrState.textContent = '로딩중';
    ocrWorker = await Tesseract.createWorker();
    await ocrWorker.loadLanguage(lang);
    await ocrWorker.initialize(lang);
    els.ocrState.textContent = '준비';
    return ocrWorker;
  }
  async function ocrCanvas(canvas, lang = 'kor'){
    await ensureOCR(lang);
    const opts = { tessedit_pageseg_mode: 7 }; // 단일 라인
    const { data:{ text } } = await ocrWorker.recognize(canvas, opts);
    return (text||'').trim().replace(/\s/g,'');
  }

  // ---------- 색상 마스킹(타이틀 전처리) ----------
  function maskTitleColors(canvas) {
    const src = canvas.getContext('2d', { willReadFrequently:true })
                      .getImageData(0,0,canvas.width,canvas.height);
    const { data, width:w, height:h } = src;
    const out = new ImageData(w, h);
    const dst = out.data;

    for (let i=0;i<data.length;i+=4){
      const r=data[i]/255, g=data[i+1]/255, b=data[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const v=max, s=max===0?0:(max-min)/max;
      let hdeg=0;
      if(max!==min){
        if(max===r) hdeg=(60*((g-b)/(max-min))+360)%360;
        else if(max===g) hdeg=60*((b-r)/(max-min))+120;
        else             hdeg=60*((r-g)/(max-min))+240;
      }
      // 초록/파랑/보라 + 최소 채도/명도
      const isColor = (
        s > 0.35 && v > 0.45 &&
        ((hdeg>=70 && hdeg<160) || (hdeg>=180 && hdeg<250) || (hdeg>=260 && hdeg<330))
      );
      const val = isColor ? 255 : 0;
      dst[i]=dst[i+1]=dst[i+2]=val; dst[i+3]=255;
    }

    const c = document.createElement('canvas');
    c.width=w; c.height=h;
    c.getContext('2d').putImageData(out,0,0);
    return c;
  }

  // ---------- OCR 강화 전처리(OpenCV) ----------
  function enhanceForOCR(canvas){
    const src = cv.imread(canvas);
    let gray = new cv.Mat();
    if (src.channels() === 4) cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    else                      cv.cvtColor(src, gray, cv.COLOR_RGB2GRAY);

    // 1) 2배 확대 + 블러
    let up = new cv.Mat();
    cv.resize(gray, up, new cv.Size(0,0), 2, 2, cv.INTER_CUBIC);
    cv.GaussianBlur(up, up, new cv.Size(3,3), 0);

    // 2) Otsu 이진화
    let bin = new cv.Mat();
    cv.threshold(up, bin, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
    // cv.bitwise_not(bin, bin); // 필요시 반전

    // 3) 형태학적 닫힘→열림
    const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
    cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel, new cv.Point(-1,-1), 1);
    cv.morphologyEx(bin, bin, cv.MORPH_OPEN,  kernel, new cv.Point(-1,-1), 1);

    const out = document.createElement('canvas');
    cv.imshow(out, bin);

    src.delete(); gray.delete(); up.delete(); bin.delete(); kernel.delete();
    return out;
  }

  // ---------- 퍼지 매칭 유틸 ----------
  function lcsScore(a,b){
    const dp = Array(a.length+1).fill(0).map(()=>Array(b.length+1).fill(0));
    for(let i=1;i<=a.length;i++) for(let j=1;j<=b.length;j++)
      dp[i][j] = a[i-1]===b[j-1] ? dp[i-1][j-1]+1 : Math.max(dp[i-1][j], dp[i][j-1]);
    return dp[a.length][b.length]/Math.max(1,b.length);
  }
  function fuzzyChoice(text, candidates){
    let best={label:'', score:0};
    for(const c of candidates){
      const sc = lcsScore(text, c);
      if(sc>best.score) best={label:c, score:sc};
    }
    return best;
  }

  // ---------- 파싱 & 등급 판정 ----------
  function parseGemLabelKOR(txtRaw){
    if(!txtRaw) return '';
    let s = txtRaw.replace(/\s/g,'')
                  .replace(/[｜|∶：]/g,':')
                  .replace(/의?젬/g,'')              // '질서의젬'/'질서젬' → '질서'
                  .replace(/[^\uAC00-\uD7A3:]/g,''); // 한글/콜론 외 제거

    const table = [
      ['질셔','질서'],['혼동','혼돈'],
      ['안쩡','안정'],['안성','안정'],['걍고','견고'],
      ['불펀','불변'],['침싯','침식'],['왜걱','왜곡'],['붕괘','붕괴']
    ];
    for(const [a,b] of table) s = s.replaceAll(a,b);

    const kindBest = fuzzyChoice(s, ['질서','혼돈']);
    const nameBest = fuzzyChoice(s, ['안정','견고','불변','침식','왜곡','붕괴']);

    if(kindBest.score >= 0.6 && nameBest.score >= 0.55)
      return `${kindBest.label}:${nameBest.label}`;

    const m = /(질서|혼돈)\s*[:：]\s*(안정|견고|불변|침식|왜곡|붕괴)/.exec(s);
    if(m) return `${m[1]}:${m[2]}`;

    return '';
  }
  function hueToGrade(h){
    if(h>=70 && h<160)  return '고급';   // Green
    if(h>=180 && h<250) return '희귀';   // Blue
    if(h>=260 && h<330) return '영웅';   // Violet
    return '';
  }
  function dominantHueFromCanvas(canvas){
    const ctx = canvas.getContext('2d', { willReadFrequently:true });
    const {width:w, height:h} = canvas;
    const data = ctx.getImageData(0,0,w,h).data;
    const hues=[];
    for(let i=0;i<data.length;i+=4){
      const r=data[i]/255,g=data[i+1]/255,b=data[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const v=max, s=max===0?0:(max-min)/max;
      if(v<0.45 || s<0.35) continue;
      let hdeg=0;
      if(max!==min){
        if(max===r) hdeg=(60*((g-b)/(max-min))+360)%360;
        else if(max===g) hdeg=60*((b-r)/(max-min))+120;
        else hdeg=60*((r-g)/(max-min))+240;
      }
      hues.push(hdeg);
    }
    if(!hues.length) return NaN;
    hues.sort((a,b)=>a-b);
    return hues[hues.length>>1];
  }

  // ---------- 감지 ----------
  async function detectOnce(){
    const imgData = drawFrame();
    if(!imgData){ setStatus('비디오 대기'); return; }

    const w=imgData.width, h=imgData.height;
    const rectTitle = pct2rect(w,h, +els.gradeL.value, +els.gradeT.value, +els.gradeR.value, +els.gradeB.value);
    const rectGem   = pct2rect(w,h, +els.gemL.value,   +els.gemT.value,   +els.gemR.value,   +els.gemB.value);

    // 타이틀 캔버스 & 전처리(색상 마스킹 → OCR 강화)
    const titleCanvas   = cropImageData(imgData, rectTitle);
    const masked        = maskTitleColors(titleCanvas);
    const ocrReady      = enhanceForOCR(masked);

    // 1차: 한글 전용 OCR
    let titleText = '';
    try { titleText = await ocrCanvas(ocrReady, 'kor'); } catch(e){ console.error(e); }
    // 2차: 실패 시 kor+eng로 재시도
    if(!titleText){
      try { titleText = await ocrCanvas(ocrReady, 'kor+eng'); } catch(e){ console.error(e); }
    }

    const gemLabel   = parseGemLabelKOR(titleText) || '(미확인)';
    const H          = dominantHueFromCanvas(titleCanvas);
    const gradeLabel = Number.isNaN(H) ? '' : hueToGrade(H);

    els.outGrade.textContent = gradeLabel ? `${gradeLabel}` : '(등급 미확인)';
    els.outGem.textContent   = gemLabel;
    els.outDbg.textContent   = `OCR:"${titleText}"  H:${Number.isNaN(H)?'NaN':H.toFixed(1)}°`;

    // 오버레이(두 박스 표시)
    const ctx = els.canvas.getContext('2d');
    ctx.save();
    ctx.strokeStyle='#6aa6ff'; ctx.lineWidth=2;
    ctx.strokeRect(rectTitle.x, rectTitle.y, rectTitle.w, rectTitle.h);
    ctx.strokeStyle='#85d996'; ctx.lineWidth=2;
    ctx.strokeRect(rectGem.x, rectGem.y, rectGem.w, rectGem.h);
    ctx.restore();
  }
  async function loopDetect(){
    loopOn=!loopOn;
    els.btnLoop.textContent = loopOn ? '연속 감지 중지' : '연속 감지 시작';
    while(loopOn){ await detectOnce(); await sleep(200); }
  }

  // ---------- 드래그로 ROI 지정 ----------
  (function enableRoiDrag(){
    const c = els.canvas;
    const ctx = c.getContext('2d', { willReadFrequently:true });
    let dragging=false, start={x:0,y:0}, cur={x:0,y:0};

    function canvasPoint(e){
      const r=c.getBoundingClientRect();
      const x=Math.round((e.clientX-r.left)*(c.width/r.width));
      const y=Math.round((e.clientY-r.top)*(c.height/r.height));
      return {x,y};
    }
    function getRect(){
      const x1=Math.min(start.x,cur.x), y1=Math.min(start.y,cur.y);
      const x2=Math.max(start.x,cur.x), y2=Math.max(start.y,cur.y);
      return {x:x1,y:y1,w:Math.max(1,x2-x1),h:Math.max(1,y2-y1)};
    }
    function pxToPct(rect){
      const w=c.width,h=c.height;
      const l=Math.max(0,Math.min(100,(rect.x/w)*100));
      const t=Math.max(0,Math.min(100,(rect.y/h)*100));
      const r=Math.max(0,Math.min(100,((rect.x+rect.w)/w)*100));
      const b=Math.max(0,Math.min(100,((rect.y+rect.h)/h)*100));
      return {l,t,r,b};
    }
    function drawPreview(){
      const imgData = drawFrame(); if(!imgData) return;
      const rect = getRect();
      ctx.save();
      ctx.strokeStyle='#ffcc66'; ctx.setLineDash([6,4]); ctx.lineWidth=2;
      ctx.strokeRect(rect.x,rect.y,rect.w,rect.h);
      ctx.restore();
    }

    c.addEventListener('mousedown', (e)=>{ if(!c.width) return; dragging=true; start=cur=canvasPoint(e); });
    c.addEventListener('mousemove', (e)=>{ if(!dragging) return; cur=canvasPoint(e); drawPreview(); });
    window.addEventListener('mouseup', ()=>{
      if(!dragging) return; dragging=false;
      const rect = getRect(); const pct = pxToPct(rect);
      const target = els.roiTarget.value; // 'grade' or 'gem'
      if(target==='grade'){ els.gradeL.value=pct.l|0; els.gradeT.value=pct.t|0; els.gradeR.value=pct.r|0; els.gradeB.value=pct.b|0; }
      else{ els.gemL.value=pct.l|0; els.gemT.value=pct.t|0; els.gemR.value=pct.r|0; els.gemB.value=pct.b|0; }
      detectOnce();
    });
  })();

  // ---------- 이벤트 ----------
  els.btnStart.addEventListener('click', async ()=>{
    try{
      stream = await navigator.mediaDevices.getDisplayMedia({ video:{ frameRate:{ideal:30,max:60} }, audio:false });
      els.video.srcObject = stream; setStatus('화면 공유 중');
    }catch(e){ console.error(e); setStatus('거부됨'); }
  });
  els.btnGrab.addEventListener('click', detectOnce);
  els.btnLoop.addEventListener('click', loopDetect);

  // OpenCV ready 체크
  (function waitCv(){
    if(typeof cv!=='undefined' && cv && (cv.Mat || cv.getBuildInformation)){
      cv['onRuntimeInitialized']=()=>{ cvReady=true; els.cvState.textContent='준비'; };
      if(cv.Mat){ cvReady=true; els.cvState.textContent='준비'; }
    } else setTimeout(waitCv,120);
  })();
</script>
</body>
</html>
