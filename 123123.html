<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>로스트아크 젬 인식 (한글 화이트리스트 OCR + 디버그 썸네일)</title>
  <style>
    :root { --bg:#0b1016; --panel:#121a24; --ink:#e9f1ff; --muted:#8ea3b6; --accent:#6aa6ff; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple SD Gothic Neo,Noto Sans KR,"맑은 고딕",sans-serif}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
    h1{font-size:22px;margin:0 0 8px}
    small{color:var(--muted)}
    .grid{display:grid;gap:12px}
    @media(min-width:920px){.grid{grid-template-columns: 1.1fr 1fr}}
    .card{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="number"], select{background:#0c141d;border:1px solid rgba(255,255,255,.08);border-radius:8px;color:var(--ink);padding:8px}
    button{background:var(--accent);color:#02152c;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;color:var(--ink);border:1px solid rgba(255,255,255,.18)}
    .pill{display:inline-flex;gap:8px;align-items:center;background:#0e1620;border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:6px 10px;color:var(--muted)}
    .kv{display:grid;grid-template-columns: 120px 1fr;gap:6px;font-size:14px}
    .kv b{color:var(--muted)}
    canvas, video{max-width:100%;background:#0c141d;border-radius:12px;border:1px dashed rgba(255,255,255,.1)}
    .section-title{font-size:13px;color:var(--muted);margin:6px 0 8px}
    .hr{height:1px;background:rgba(255,255,255,.07);margin:10px -14px}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#162234;color:#9ec0ff;font-size:12px}
  </style>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>아크 그리드 젬 인식 <span class="tag">웹</span></h1>
    <small>타이틀(예: “질서의 젬 : 안정”) 영역을 드래그로 지정 → 색상 마스킹·전처리 → <b>한글 화이트리스트 OCR</b> → 퍼지 매칭으로 젬 종류 인식, 주색상으로 등급 판정. (HTTPS 또는 http://localhost 필요)</small>

    <div class="grid" style="margin-top:14px">
      <!-- LEFT -->
      <div class="card">
        <div class="row">
          <button id="btnStart">화면 캡처 허용</button>
          <button id="btnGrab" class="ghost">한 프레임 분석</button>
          <button id="btnLoop" class="ghost">연속 감지 시작</button>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="pill">상태: <span id="status">대기</span></span>
          <span class="pill">OpenCV: <span id="cvState">로딩중</span></span>
          <span class="pill">Tesseract: <span id="ocrState">준비</span></span>
        </div>

        <div class="hr"></div>
        <div class="row">
          <div style="flex:1 1 320px">
            <div class="section-title">라이브 미리보기</div>
            <video id="video" autoplay playsinline muted></video>
          </div>
          <div style="flex:1 1 320px">
            <div class="section-title">분석 캔버스 (여기서 드래그)</div>
            <canvas id="canvas"></canvas>
          </div>
        </div>

        <div class="hr"></div>
        <div class="row">
          <div>
            <div class="section-title">ROI · 타이틀 텍스트/색상(%)</div>
            <div class="row">
              <label>left <input id="gradeL" type="number" value="46" min="0" max="100" style="width:80px">%</label>
              <label>top <input id="gradeT" type="number" value="14" min="0" max="100" style="width:80px">%</label>
              <label>right <input id="gradeR" type="number" value="54" min="0" max="100" style="width:80px">%</label>
              <label>bottom <input id="gradeB" type="number" value="20" min="0" max="100" style="width:80px">%</label>
            </div>
          </div>
          <div>
            <div class="section-title">ROI · (옵션) 젬 아이콘(%)</div>
            <div class="row">
              <label>left <input id="gemL" type="number" value="44" min="0" max="100" style="width:80px">%</label>
              <label>top <input id="gemT" type="number" value="24" min="0" max="100" style="width:80px">%</label>
              <label>right <input id="gemR" type="number" value="56" min="0" max="100" style="width:80px">%</label>
              <label>bottom <input id="gemB" type="number" value="38" min="0" max="100" style="width:80px">%</label>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:8px">
          <label>드래그 대상
            <select id="roiTarget">
              <option value="grade">타이틀 ROI (파란 박스)</option>
              <option value="gem">젬 아이콘 ROI (초록 박스)</option>
            </select>
          </label>
          <small style="color:#8ea3b6">캔버스 위에서 드래그 → 선택한 ROI가 갱신됩니다</small>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="section-title">결과</div>
        <div class="kv">
          <b>등급</b><div id="outGrade">-</div>
          <b>젬 종류</b><div id="outGem">-</div>
          <b>디버그</b><div id="outDbg" style="white-space:pre-wrap;color:var(--muted)">-</div>
        </div>

        <div class="section-title" style="margin-top:12px">디버그 입력 미리보기</div>
        <canvas id="dbgA" width="280" height="60" style="background:#0c141d;border:1px dashed rgba(255,255,255,.15);border-radius:8px"></canvas>
        <canvas id="dbgB" width="280" height="60" style="background:#0c141d;border:1px dashed rgba(255,255,255,.15);border-radius:8px;margin-top:6px"></canvas>
      </div>
    </div>
  </div>

<script>
  const $ = (sel)=>document.querySelector(sel);
  const els = {
    btnStart: $('#btnStart'), btnGrab: $('#btnGrab'), btnLoop: $('#btnLoop'),
    video: $('#video'), canvas: $('#canvas'), status: $('#status'),
    gradeL: $('#gradeL'), gradeT: $('#gradeT'), gradeR: $('#gradeR'), gradeB: $('#gradeB'),
    gemL: $('#gemL'), gemT: $('#gemT'), gemR: $('#gemR'), gemB: $('#gemB'),
    outGrade: $('#outGrade'), outGem: $('#outGem'), outDbg: $('#outDbg'),
    cvState: $('#cvState'), ocrState: $('#ocrState'),
    roiTarget: $('#roiTarget'),
    dbgA: $('#dbgA'), dbgB: $('#dbgB'),
  };

  let stream=null, loopOn=false, cvReady=false;
  function setStatus(s){ els.status.textContent=s }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)) }

  function drawFrame(){
    const v=els.video, c=els.canvas, ctx=c.getContext('2d');
    if(!v.videoWidth) return null;
    c.width=v.videoWidth; c.height=v.videoHeight;
    ctx.drawImage(v,0,0,c.width,c.height);
    return ctx.getImageData(0,0,c.width,c.height);
  }
  function pct2rect(w,h,l,t,r,b){
    const x1=Math.round(w*(l/100)), y1=Math.round(h*(t/100));
    const x2=Math.round(w*(r/100)), y2=Math.round(h*(b/100));
    return {x:x1,y:y1,w:Math.max(1,x2-x1),h:Math.max(1,y2-y1)};
  }
  function cropImageData(imgData, rect){
    const {x,y,w,h}=rect;
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    const ctx=c.getContext('2d'); ctx.putImageData(imgData,-x,-y);
    return c;
  }

  // ====== OCR (한글 화이트리스트 + 안전한 언어 전환) ======
  const WL = '질서혼돈의젬안정견고불변침식왜곡붕괴:'; // 허용 문자
  const BL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; // 차단 문자

  let ocrWorker=null;
  let currentLang='';
  async function ensureOCR(lang='kor'){
    if(!ocrWorker){
      els.ocrState.textContent='로딩중';
      ocrWorker = await Tesseract.createWorker();
    }
    if(currentLang !== lang){
      await ocrWorker.loadLanguage(lang);
      await ocrWorker.initialize(lang);
      currentLang = lang;
      els.ocrState.textContent='준비';
    }
    return ocrWorker;
  }
  async function doOCR(canvas, lang='kor'){
    await ensureOCR(lang);
    await ocrWorker.setParameters({
      tessedit_pageseg_mode: '7',
      tessedit_char_whitelist: WL,
      tessedit_char_blacklist: BL,
      preserve_interword_spaces: '1'
    });
    const { data } = await ocrWorker.recognize(canvas);
    return { text:(data.text||'').trim().replace(/\s/g,''), conf:data.confidence||0 };
  }

  // ====== 색상 마스킹 & 트림 ======
  function maskTitleColors(canvas){
    const src = canvas.getContext('2d',{willReadFrequently:true}).getImageData(0,0,canvas.width,canvas.height);
    const {data,width:w,height:h}=src;
    const out=new ImageData(w,h), dst=out.data;
    for(let i=0;i<data.length;i+=4){
      const r=data[i]/255,g=data[i+1]/255,b=data[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const v=max, s=max===0?0:(max-min)/max;
      let hdeg=0;
      if(max!==min){
        if(max===r) hdeg=(60*((g-b)/(max-min))+360)%360;
        else if(max===g) hdeg=60*((b-r)/(max-min))+120;
        else             hdeg=60*((r-g)/(max-min))+240;
      }
      // 연두~초록(55~170) / 청록~파랑(170~255) / 보라(255~340)
      const isColor = s>0.32 && v>0.42 && (
        (hdeg>=55 && hdeg<170) || (hdeg>=170 && hdeg<255) || (hdeg>=255 && hdeg<340)
      );
      const val=isColor?255:0;
      dst[i]=dst[i+1]=dst[i+2]=val; dst[i+3]=255;
    }
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    c.getContext('2d').putImageData(out,0,0); return c;
  }
  function verticalTrim(maskCanvas){
    const ctx=maskCanvas.getContext('2d',{willReadFrequently:true});
    const {width:w,height:h}=maskCanvas;
    const data=ctx.getImageData(0,0,w,h).data;
    const rowSum=new Array(h).fill(0);
    for(let y=0;y<h;y++){
      let s=0; const off=y*w*4;
      for(let x=0;x<w;x++) s+=data[off+x*4];
      rowSum[y]=s/(255*w);
    }
    const thresh=Math.max(2, Math.floor(w*0.02));
    let top=0,bottom=h-1;
    while(top<h && rowSum[top]<thresh) top++;
    while(bottom>top && rowSum[bottom]<thresh) bottom--;
    top=Math.max(0, top-2); bottom=Math.min(h-1, bottom+2);
    const out=document.createElement('canvas');
    out.width=w; out.height=bottom-top+1;
    out.getContext('2d').drawImage(maskCanvas,0,top,w,bottom-top+1,0,0,w,bottom-top+1);
    return out;
  }

  // ====== OpenCV 전처리(확대/이진/형태학 + 팽창) ======
  function enhanceForOCR(canvas){
    const src=cv.imread(canvas);
    let gray=new cv.Mat();
    if(src.channels()===4) cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
    else                   cv.cvtColor(src,gray,cv.COLOR_RGB2GRAY);
    let up=new cv.Mat();
    cv.resize(gray,up,new cv.Size(0,0),2,2,cv.INTER_CUBIC);
    cv.GaussianBlur(up,up,new cv.Size(3,3),0);
    let bin=new cv.Mat();
    cv.threshold(up,bin,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU);
    const k2=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(2,2));
    cv.morphologyEx(bin,bin,cv.MORPH_CLOSE,k2,new cv.Point(-1,-1),1);
    cv.morphologyEx(bin,bin,cv.MORPH_OPEN ,k2,new cv.Point(-1,-1),1);
    cv.dilate(bin,bin,k2,new cv.Point(-1,-1),1); // 글자 굵게
    const out=document.createElement('canvas');
    cv.imshow(out,bin);
    src.delete(); gray.delete(); up.delete(); bin.delete(); k2.delete();
    return out;
  }

  // ====== 보조(반전/그레이/픽셀비율) ======
  function canvasInvert(srcCanvas){
    const c=document.createElement('canvas'); c.width=srcCanvas.width; c.height=srcCanvas.height;
    const ctx=c.getContext('2d'); ctx.drawImage(srcCanvas,0,0);
    const id=ctx.getImageData(0,0,c.width,c.height); const d=id.data;
    for(let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
    ctx.putImageData(id,0,0); return c;
  }
  function toGrayCanvas(src){
    const c=document.createElement('canvas'); c.width=src.width; c.height=src.height;
    const ctx=c.getContext('2d'); ctx.drawImage(src,0,0);
    const id=ctx.getImageData(0,0,c.width,c.height); const d=id.data;
    for(let i=0;i<d.length;i+=4){
      const y=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2];
      d[i]=d[i+1]=d[i+2]=y;
    }
    ctx.putImageData(id,0,0); return c;
  }
  function whitePixelRatio(canvas){
    const ctx=canvas.getContext('2d',{willReadFrequently:true});
    const {width:w,height:h}=canvas; const d=ctx.getImageData(0,0,w,h).data;
    let cnt=0; for(let i=0;i<d.length;i+=4) if(d[i]>200) cnt++;
    return cnt/(d.length/4);
  }

  // ====== 퍼지/파싱 & 등급 ======
  function lcsScore(a,b){
    const dp=Array(a.length+1).fill(0).map(()=>Array(b.length+1).fill(0));
    for(let i=1;i<=a.length;i++) for(let j=1;j<=b.length;j++)
      dp[i][j]=a[i-1]===b[j-1]?dp[i-1][j-1]+1:Math.max(dp[i-1][j],dp[i][j-1]);
    return dp[a.length][b.length]/Math.max(1,b.length);
  }
  function fuzzyChoice(text, cand){ let best={label:'',score:0}; for(const c of cand){ const s=lcsScore(text,c); if(s>best.score) best={label:c,score:s}; } return best; }
  function parseGemLabelKOR(txt){
    if(!txt) return '';
    let s=txt.replace(/\s/g,'').replace(/[｜|∶：]/g,':').replace(/의?젬/g,'').replace(/[^\uAC00-\uD7A3:]/g,'');
    const fix=[['질셔','질서'],['혼동','혼돈'],['안쩡','안정'],['안성','안정'],['걍고','견고'],['불펀','불변'],['침싯','침식'],['왜걱','왜곡'],['붕괘','붕괴']];
    for(const [a,b] of fix) s=s.replaceAll(a,b);
    const kind=fuzzyChoice(s,['질서','혼돈']), name=fuzzyChoice(s,['안정','견고','불변','침식','왜곡','붕괴']);
    if(kind.score>=0.6 && name.score>=0.55) return `${kind.label}:${name.label}`;
    const m=/(질서|혼돈)\s*[:：]\s*(안정|견고|불변|침식|왜곡|붕괴)/.exec(s);
    return m?`${m[1]}:${m[2]}`:'';
  }
  function hueToGrade(h){ if(h>=55&&h<170) return '고급'; if(h>=170&&h<255) return '희귀'; if(h>=255&&h<340) return '영웅'; return ''; }
  function dominantHueFromCanvas(canvas){
    const ctx=canvas.getContext('2d',{willReadFrequently:true});
    const {width:w,height:h}=canvas; const data=ctx.getImageData(0,0,w,h).data;
    const hues=[];
    for(let i=0;i<data.length;i+=4){
      const r=data[i]/255,g=data[i+1]/255,b=data[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const v=max,s=max===0?0:(max-min)/max; if(v<0.42||s<0.32) continue;
      let hh=0;
      if(max!==min){ if(max===r) hh=(60*((g-b)/(max-min))+360)%360; else if(max===g) hh=60*((b-r)/(max-min))+120; else hh=60*((r-g)/(max-min))+240; }
      hues.push(hh);
    }
    if(!hues.length) return NaN; hues.sort((a,b)=>a-b); return hues[hues.length>>1];
  }

  function hangulRatio(s){ if(!s) return 0; const m=s.match(/[\uAC00-\uD7A3]/g); return (m?m.length:0)/s.length; }

  // ====== OCR 베스트 선택(마스크 실패 시 raw 경로 포함, 반전/언어 자동) ======
  async function ocrBest(titleCanvas){
    // 경로 A: 마스크 기반
    const masked  = maskTitleColors(titleCanvas);
    const trimmed = verticalTrim(masked);
    const ench    = enhanceForOCR(trimmed);

    // 디버그 A 표시
    (function showA(){
      const ctxA=els.dbgA.getContext('2d'); ctxA.clearRect(0,0,els.dbgA.width,els.dbgA.height);
      const r=Math.min(els.dbgA.width/ench.width, els.dbgA.height/ench.height);
      const w=Math.floor(ench.width*r), h=Math.floor(ench.height*r);
      ctxA.drawImage(ench, 0, 0, w, h);
    })();

    let tries = [
      [ench, 'kor'],
      [canvasInvert(ench), 'kor'],
      [ench, 'kor+eng'],
      [canvasInvert(ench), 'kor+eng']
    ];

    // 마스크 결과가 너무 빈약하면 경로 B: raw 그레이 → 전처리
    if (whitePixelRatio(ench) < 0.005) {
      const rawGray = toGrayCanvas(titleCanvas);
      const rawEnh  = enhanceForOCR(rawGray);

      // 디버그 B 표시
      (function showB(){
        const ctxB=els.dbgB.getContext('2d'); ctxB.clearRect(0,0,els.dbgB.width,els.dbgB.height);
        const r=Math.min(els.dbgB.width/rawEnh.width, els.dbgB.height/rawEnh.height);
        const w=Math.floor(rawEnh.width*r), h=Math.floor(rawEnh.height*r);
        ctxB.drawImage(rawEnh, 0, 0, w, h);
      })();

      tries = [
        [rawEnh, 'kor'], [canvasInvert(rawEnh),'kor'],
        [rawEnh, 'kor+eng'], [canvasInvert(rawEnh),'kor+eng'],
        ...tries
      ];
    } else {
      // 디버그 B에도 동일 이미지 복사(비어보이지 않게)
      const ctxB=els.dbgB.getContext('2d'); ctxB.clearRect(0,0,els.dbgB.width,els.dbgB.height);
      const r=Math.min(els.dbgB.width/ench.width, els.dbgB.height/ench.height);
      const w=Math.floor(ench.width*r), h=Math.floor(ench.height*r);
      ctxB.drawImage(ench, 0, 0, w, h);
    }

    let best={text:'',score:-1};
    for(const [cnv,lang] of tries){
      try{
        const {text, conf} = await doOCR(cnv, lang);
        const score = hangulRatio(text)*0.7 + (conf/100)*0.3;
        if(text && score>best.score) best={text,score};
      }catch(e){ console.error(e); }
    }
    return best.text;
  }

  // ====== 감지 ======
  async function detectOnce(){
    const imgData=drawFrame(); if(!imgData){ setStatus('비디오 대기'); return; }
    const w=imgData.width, h=imgData.height;
    const rectTitle=pct2rect(w,h,+els.gradeL.value,+els.gradeT.value,+els.gradeR.value,+els.gradeB.value);
    const rectGem  =pct2rect(w,h,+els.gemL.value,  +els.gemT.value,  +els.gemR.value,  +els.gemB.value);

    const titleCanvas=cropImageData(imgData,rectTitle);

    let titleText = await ocrBest(titleCanvas);
    const gemLabel = parseGemLabelKOR(titleText) || '(미확인)';

    const H = dominantHueFromCanvas(titleCanvas);
    const gradeLabel = Number.isNaN(H) ? '' : hueToGrade(H);

    els.outGrade.textContent = gradeLabel ? `${gradeLabel}` : '(등급 미확인)';
    els.outGem.textContent   = gemLabel;
    els.outDbg.textContent   = `OCR:"${titleText}"  H:${Number.isNaN(H)?'NaN':H.toFixed(1)}°`;

    const ctx=els.canvas.getContext('2d');
    ctx.save();
    ctx.strokeStyle='#6aa6ff'; ctx.lineWidth=2; ctx.strokeRect(rectTitle.x,rectTitle.y,rectTitle.w,rectTitle.h);
    ctx.strokeStyle='#85d996'; ctx.lineWidth=2; ctx.strokeRect(rectGem.x,rectGem.y,rectGem.w,rectGem.h);
    ctx.restore();
  }
  async function loopDetect(){ loopOn=!loopOn; els.btnLoop.textContent=loopOn?'연속 감지 중지':'연속 감지 시작'; while(loopOn){ await detectOnce(); await sleep(200); } }

  // ====== 드래그 ROI ======
  (function enableRoiDrag(){
    const c=els.canvas, ctx=c.getContext('2d',{willReadFrequently:true});
    let dragging=false,start={x:0,y:0},cur={x:0,y:0};
    function canvasPoint(e){ const r=c.getBoundingClientRect(); return {x:Math.round((e.clientX-r.left)*(c.width/r.width)), y:Math.round((e.clientY-r.top)*(c.height/r.height))}; }
    function getRect(){ const x1=Math.min(start.x,cur.x),y1=Math.min(start.y,cur.y),x2=Math.max(start.x,cur.x),y2=Math.max(start.y,cur.y); return {x:x1,y:y1,w:Math.max(1,x2-x1),h:Math.max(1,y2-y1)}; }
    function pxToPct(rect){ const w=c.width,h=c.height; return { l:Math.max(0,Math.min(100,(rect.x/w)*100)), t:Math.max(0,Math.min(100,(rect.y/h)*100)), r:Math.max(0,Math.min(100,((rect.x+rect.w)/w)*100)), b:Math.max(0,Math.min(100,((rect.y+rect.h)/h)*100)) }; }
    function drawPreview(){ const imgData=drawFrame(); if(!imgData) return; const r=getRect(); ctx.save(); ctx.strokeStyle='#ffcc66'; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.restore(); }
    c.addEventListener('mousedown',e=>{ if(!c.width) return; dragging=true; start=cur=canvasPoint(e); });
    c.addEventListener('mousemove',e=>{ if(!dragging) return; cur=canvasPoint(e); drawPreview(); });
    window.addEventListener('mouseup',()=>{ if(!dragging) return; dragging=false; const r=getRect(), p=pxToPct(r), tgt=els.roiTarget.value; if(tgt==='grade'){ els.gradeL.value=p.l|0; els.gradeT.value=p.t|0; els.gradeR.value=p.r|0; els.gradeB.value=p.b|0; } else { els.gemL.value=p.l|0; els.gemT.value=p.t|0; els.gemR.value=p.r|0; els.gemB.value=p.b|0; } detectOnce(); });
  })();

  // ====== 이벤트 ======
  els.btnStart.addEventListener('click', async ()=>{
    try{ stream=await navigator.mediaDevices.getDisplayMedia({video:{frameRate:{ideal:30,max:60}},audio:false}); els.video.srcObject=stream; setStatus('화면 공유 중'); }
    catch(e){ console.error(e); setStatus('거부됨'); }
  });
  els.btnGrab.addEventListener('click', detectOnce);
  els.btnLoop.addEventListener('click', loopDetect);

  (function waitCv(){
    if(typeof cv!=='undefined' && cv && (cv.Mat||cv.getBuildInformation)){ cv['onRuntimeInitialized']=()=>{ cvReady=true; els.cvState.textContent='준비'; }; if(cv.Mat){ cvReady=true; els.cvState.textContent='준비'; } }
    else setTimeout(waitCv,120);
  })();
</script>
</body>
</html>
