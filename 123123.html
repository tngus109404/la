<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>로스트아크 젬 인식 (화면공유 + ROI 드래그 / 6종 라벨 + 3색 분류)</title>
  <style>
    :root { --bg:#0b1016; --panel:#121a24; --ink:#e9f1ff; --muted:#8ea3b6; --accent:#6aa6ff; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple SD Gothic Neo,Noto Sans KR,"맑은 고딕",sans-serif}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
    h1{font-size:22px;margin:0 0 8px}
    small{color:var(--muted)}
    .grid{display:grid;gap:12px}
    @media(min-width:920px){.grid{grid-template-columns: 1.1fr 1fr}}
    .card{background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="number"], select{background:#0c141d;border:1px solid rgba(255,255,255,.08);border-radius:8px;color:var(--ink);padding:8px}
    button{background:var(--accent);color:#02152c;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;color:var(--ink);border:1px solid rgba(255,255,255,.18)}
    .pill{display:inline-flex;gap:8px;align-items:center;background:#0e1620;border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:6px 10px;color:var(--muted)}
    .kv{display:grid;grid-template-columns: 120px 1fr;gap:6px;font-size:14px}
    .kv b{color:var(--muted)}
    canvas, video{max-width:100%;background:#0c141d;border-radius:12px;border:1px dashed rgba(255,255,255,.1)}
    .section-title{font-size:13px;color:var(--muted);margin:6px 0 8px}
    .hr{height:1px;background:rgba(255,255,255,.07);margin:10px -14px}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#162234;color:#9ec0ff;font-size:12px}
  </style>
  <!-- OpenCV.js (영상 전처리용) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <!-- Tesseract.js (브라우저 OCR / 한글 지원) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>로스트아크 젬 인식 <span class="tag">웹</span></h1>
    <small>화면공유 허용 → 게임 창 선택 → 우측 캔버스에서 ROI 드래그 → <b>젬 이름 6종</b> + <b>색상 3종</b> 인식. (HTTPS 또는 http://localhost 권장)</small>

    <div class="grid" style="margin-top:14px">
      <!-- LEFT -->
      <div class="card">
        <div class="row">
          <button id="btnStart">화면 캡처 허용</button>
          <button id="btnGrab" class="ghost">한 프레임 분석</button>
          <button id="btnLoop" class="ghost">연속 감지 시작</button>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="pill">상태: <span id="status">대기</span></span>
          <span class="pill">OpenCV: <span id="cvState">로딩중</span></span>
          <span class="pill">Tesseract: <span id="ocrState">준비</span></span>
        </div>

        <div class="hr"></div>
        <div class="row">
          <div style="flex:1 1 320px">
            <div class="section-title">라이브 미리보기</div>
            <video id="video" autoplay playsinline muted></video>
          </div>
          <div style="flex:1 1 320px">
            <div class="section-title">분석 캔버스 (여기서 드래그)</div>
            <canvas id="canvas"></canvas>
          </div>
        </div>

        <div class="hr"></div>
        <div class="row">
          <div>
            <div class="section-title">ROI · 타이틀 텍스트(%)</div>
            <div class="row">
              <label>left <input id="gradeL" type="number" value="46" min="0" max="100" style="width:80px">%</label>
              <label>top <input id="gradeT" type="number" value="14" min="0" max="100" style="width:80px">%</label>
              <label>right <input id="gradeR" type="number" value="54" min="0" max="100" style="width:80px">%</label>
              <label>bottom <input id="gradeB" type="number" value="20" min="0" max="100" style="width:80px">%</label>
            </div>
          </div>
          <div>
            <div class="section-title">ROI · (옵션) 젬 아이콘(%)</div>
            <div class="row">
              <label>left <input id="gemL" type="number" value="44" min="0" max="100" style="width:80px">%</label>
              <label>top <input id="gemT" type="number" value="24" min="0" max="100" style="width:80px">%</label>
              <label>right <input id="gemR" type="number" value="56" min="0" max="100" style="width:80px">%</label>
              <label>bottom <input id="gemB" type="number" value="38" min="0" max="100" style="width:80px">%</label>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:8px">
          <label>드래그 대상
            <select id="roiTarget">
              <option value="grade">타이틀 ROI (파란 박스)</option>
              <option value="gem">젬 아이콘 ROI (초록 박스)</option>
            </select>
          </label>
          <small style="color:#8ea3b6">캔버스 위에서 드래그 → 선택한 ROI가 갱신됩니다</small>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="section-title">결과</div>
        <div class="kv">
          <b>젬 종류</b><div id="outGem">-</div>
          <b>색상</b><div id="outGrade">-</div>
          <b>디버그</b><div id="outDbg" style="white-space:pre-wrap;color:var(--muted)">-</div>
        </div>

        <div class="section-title" style="margin-top:12px">디버그 입력 미리보기</div>
        <canvas id="dbgA" width="280" height="60" style="background:#0c141d;border:1px dashed rgba(255,255,255,.15);border-radius:8px"></canvas>
        <canvas id="dbgB" width="280" height="60" style="background:#0c141d;border:1px dashed rgba(255,255,255,.15);border-radius:8px;margin-top:6px"></canvas>
      </div>
    </div>
  </div>

<script>
  const $ = (sel)=>document.querySelector(sel);
  const els = {
    btnStart: $('#btnStart'), btnGrab: $('#btnGrab'), btnLoop: $('#btnLoop'),
    video: $('#video'), canvas: $('#canvas'), status: $('#status'),
    gradeL: $('#gradeL'), gradeT: $('#gradeT'), gradeR: $('#gradeR'), gradeB: $('#gradeB'),
    gemL: $('#gemL'), gemT: $('#gemT'), gemR: $('#gemR'), gemB: $('#gemB'),
    outGrade: $('#outGrade'), outGem: $('#outGem'), outDbg: $('#outDbg'),
    cvState: $('#cvState'), ocrState: $('#ocrState'),
    roiTarget: $('#roiTarget'),
    dbgA: $('#dbgA'), dbgB: $('#dbgB'),
  };

  let stream=null, loopOn=false;
  function setStatus(s){ els.status.textContent=s }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)) }

  // ====== 그리기/ROI ====
  function drawFrame(){
    const v = els.video;
    const c = els.canvas, ctx = c.getContext('2d', { willReadFrequently:true });
    if(!v.videoWidth) return null;
    const dpr = window.devicePixelRatio || 1;
    c.width  = Math.floor(v.videoWidth  * dpr);
    c.height = Math.floor(v.videoHeight * dpr);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(v, 0, 0, c.width, c.height);
    return ctx.getImageData(0,0,c.width,c.height);
  }
  function pct2rect(w,h,l,t,r,b){
    const x1=Math.round(w*(l/100)), y1=Math.round(h*(t/100));
    const x2=Math.round(w*(r/100)), y2=Math.round(h*(b/100));
    return {x:x1,y:y1,w:Math.max(1,x2-x1),h:Math.max(1,y2-y1)};
  }
  function cropImageData(imgData, rect){
    const {x,y,w,h}=rect;
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    const ctx=c.getContext('2d'); ctx.putImageData(imgData,-x,-y);
    return c;
  }

  // ====== OCR (한글 화이트리스트) ======
  const WL = '질서혼돈의젬안정견고불변침식왜곡붕괴:';
  const BL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let ocrWorker=null, currentLang='';
  async function ensureOCR(lang='kor'){
    if(!ocrWorker){
      els.ocrState.textContent='로딩중';
      ocrWorker = await Tesseract.createWorker();
    }
    if(currentLang !== lang){
      await ocrWorker.loadLanguage(lang);
      await ocrWorker.initialize(lang);
      currentLang = lang;
      els.ocrState.textContent='준비';
    }
    return ocrWorker;
  }
  async function doOCR(canvas, lang='kor'){
    await ensureOCR(lang);
    await ocrWorker.setParameters({
      tessedit_pageseg_mode: '7',
      tessedit_char_whitelist: WL,
      tessedit_char_blacklist: BL,
      preserve_interword_spaces: '1',
      user_defined_dpi: '300'
    });
    const { data } = await ocrWorker.recognize(canvas);
    return { text:(data.text||'').trim().replace(/\s/g,''), conf:data.confidence||0 };
  }

  // ====== 색상 마스킹/전처리 ======
  function maskTitleColors(canvas){
    const src = canvas.getContext('2d',{willReadFrequently:true}).getImageData(0,0,canvas.width,canvas.height);
    const {data,width:w,height:h}=src;
    const out=new ImageData(w,h), dst=out.data;
    for(let i=0;i<data.length;i+=4){
      const r=data[i]/255,g=data[i+1]/255,b=data[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const v=max, s=max===0?0:(max-min)/max;
      let hdeg=0;
      if(max!==min){
        if(max===r) hdeg=(60*((g-b)/(max-min))+360)%360;
        else if(max===g) hdeg=60*((b-r)/(max-min))+120;
        else             hdeg=60*((r-g)/(max-min))+240;
      }
      // 초록(55~170), 파랑(170~255), 보라(255~340)만 허용
      const isColor = s>0.32 && v>0.42 && (
        (hdeg>=55 && hdeg<170) || (hdeg>=170 && hdeg<255) || (hdeg>=255 && hdeg<340)
      );
      const val=isColor?255:0;
      dst[i]=dst[i+1]=dst[i+2]=val; dst[i+3]=255;
    }
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    c.getContext('2d').putImageData(out,0,0); return c;
  }
  function verticalTrim(maskCanvas){
    const ctx=maskCanvas.getContext('2d',{willReadFrequently:true});
    const {width:w,height:h}=maskCanvas;
    const data=ctx.getImageData(0,0,w,h).data;
    const rowSum=new Array(h).fill(0);
    for(let y=0;y<h;y++){
      let s=0; const off=y*w*4;
      for(let x=0;x<w;x++) s+=data[off+x*4];
      rowSum[y]=s/(255*w);
    }
    const thresh=Math.max(2, Math.floor(w*0.02));
    let top=0,bottom=h-1;
    while(top<h && rowSum[top]<thresh) top++;
    while(bottom>top && rowSum[bottom]<thresh) bottom--;
    top=Math.max(0, top-2); bottom=Math.min(h-1, bottom+2);
    const out=document.createElement('canvas');
    out.width=w; out.height=bottom-top+1;
    out.getContext('2d').drawImage(maskCanvas,0,top,w,bottom-top+1,0,0,w,bottom-top+1);
    return out;
  }
  function enhanceForOCR(canvas){
    const UPSCALE = 3;
    const src = cv.imread(canvas);
    let gray = new cv.Mat();
    if (src.channels() === 4) cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    else                      cv.cvtColor(src, gray, cv.COLOR_RGB2GRAY);
    let up = new cv.Mat();
    cv.resize(gray, up, new cv.Size(0,0), UPSCALE, UPSCALE, cv.INTER_CUBIC);
    let blur = new cv.Mat();
    cv.GaussianBlur(up, blur, new cv.Size(0,0), 1.2);
    cv.addWeighted(up, 1.5, blur, -0.5, 0, up); blur.delete();
    let bin = new cv.Mat();
    cv.threshold(up, bin, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
    const k2 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
    cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k2, new cv.Point(-1,-1), 1);
    cv.morphologyEx(bin, bin, cv.MORPH_OPEN , k2, new cv.Point(-1,-1), 1);
    cv.dilate(bin, bin, k2, new cv.Point(-1,-1), 1);
    const out = document.createElement('canvas');
    cv.imshow(out, bin);
    src.delete(); gray.delete(); up.delete(); bin.delete(); k2.delete();
    return out;
  }
  function canvasInvert(srcCanvas){
    const c=document.createElement('canvas'); c.width=srcCanvas.width; c.height=srcCanvas.height;
    const ctx=c.getContext('2d'); ctx.drawImage(srcCanvas,0,0);
    const id=ctx.getImageData(0,0,c.width,c.height); const d=id.data;
    for(let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
    ctx.putImageData(id,0,0); return c;
  }
  function toGrayCanvas(src){
    const c=document.createElement('canvas'); c.width=src.width; c.height=src.height;
    const ctx=c.getContext('2d'); ctx.drawImage(src,0,0);
    const id=ctx.getImageData(0,0,c.width,c.height); const d=id.data;
    for(let i=0;i<d.length;i+=4){
      const y=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2];
      d[i]=d[i+1]=d[i+2]=y;
    }
    ctx.putImageData(id,0,0); return c;
  }
  function whitePixelRatio(canvas){
    const ctx=canvas.getContext('2d',{willReadFrequently:true});
    const {width:w,height:h}=canvas; const d=ctx.getImageData(0,0,w,h).data;
    let cnt=0; for(let i=0;i<d.length;i+=4) if(d[i]>200) cnt++;
    return cnt/(d.length/4);
  }

  // ====== 젬 6종 강제 분류 ======
  const FIX = [['질셔','질서'],['혼동','혼돈'],['점','젬'],['안쩡','안정'],['안성','안정'],['걍고','견고'],['불펀','불변'],['침싯','침식'],['왜걱','왜곡'],['붕괘','붕괴']];
  function parseGemLabelKOR(txt){
    if(!txt) return '';
    let s=txt.replace(/\s/g,'').replace(/[｜|∶：]/g,':').replace(/의?젬/g,'').replace(/[^\uAC00-\uD7A3:]/g,'');
    for(const [a,b] of FIX) s=s.replaceAll(a,b);
    const m=/(질서|혼돈)\s*[:：]?\s*(안정|견고|불변|침식|왜곡|붕괴)/.exec(s);
    return m?`${m[1]}의 젬 : ${m[2]}`:'';
  }

  // ====== 색 3종 강제 분류 (green/blue/purple) ======
  function dominantHueFromCanvas(canvas){
    const ctx=canvas.getContext('2d',{willReadFrequently:true});
    const {width:w,height:h}=canvas; const data=ctx.getImageData(0,0,w,h).data;
    const hues=[];
    for(let i=0;i<data.length;i+=4){
      const r=data[i]/255,g=data[i+1]/255,b=data[i+2]/255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const v=max,s=max===0?0:(max-min)/max; if(v<0.42||s<0.32) continue;
      let hh=0;
      if(max!==min){
        if(max===r) hh=(60*((g-b)/(max-min))+360)%360;
        else if(max===g) hh=60*((b-r)/(max-min))+120;
        else             hh=60*((r-g)/(max-min))+240;
      }
      hues.push(hh);
    }
    if(!hues.length) return NaN;
    hues.sort((a,b)=>a-b);
    return hues[hues.length>>1]; // 중앙값
  }
  function hueToClass(h){
    if(isNaN(h)) return '';
    if(h>=55 && h<170) return 'green';
    if(h>=170 && h<255) return 'blue';
    if(h>=255 && h<340) return 'purple';
    // 경계값 보정
    if(h>=45 && h<55) return 'green';
    if(h>=340 && h<360) return 'purple';
    return '';
  }

  // ====== OCR 베스트 선택(마스크 실패 시 raw 경로 포함) ======
  function hangulRatio(s){ if(!s) return 0; const m=s.match(/[\uAC00-\uD7A3]/g); return (m?m.length:0)/s.length; }
  async function ocrBest(titleCanvas){
    // 마스크 전처리 경로
    const masked  = maskTitleColors(titleCanvas);
    const trimmed = verticalTrim(masked);
    const ench    = enhanceForOCR(trimmed);
    // 디버그 표시
    (function showA(){
      const ctxA=els.dbgA.getContext('2d'); ctxA.clearRect(0,0,els.dbgA.width,els.dbgA.height);
      const r=Math.min(els.dbgA.width/ench.width, els.dbgA.height/ench.height);
      ctxA.drawImage(ench, 0, 0, Math.floor(ench.width*r), Math.floor(ench.height*r));
    })();

    let tries = [[ench,'kor'], [canvasInvert(ench),'kor'], [ench,'kor+eng'], [canvasInvert(ench),'kor+eng']];

    // 마스크가 빈약하면 raw 경로 추가
    if (whitePixelRatio(ench) < 0.005) {
      const rawGray = toGrayCanvas(titleCanvas);
      const rawEnh  = enhanceForOCR(rawGray);
      (function showB(){
        const ctxB=els.dbgB.getContext('2d'); ctxB.clearRect(0,0,els.dbgB.width,els.dbgB.height);
        const r=Math.min(els.dbgB.width/rawEnh.width, els.dbgB.height/rawEnh.height);
        ctxB.drawImage(rawEnh, 0, 0, Math.floor(rawEnh.width*r), Math.floor(rawEnh.height*r));
      })();
      tries = [[rawEnh,'kor'], [canvasInvert(rawEnh),'kor'], [rawEnh,'kor+eng'], [canvasInvert(rawEnh),'kor+eng'], ...tries];
    }else{
      const ctxB=els.dbgB.getContext('2d'); ctxB.clearRect(0,0,els.dbgB.width,els.dbgB.height);
      const r=Math.min(els.dbgB.width/ench.width, els.dbgB.height/ench.height);
      ctxB.drawImage(ench, 0, 0, Math.floor(ench.width*r), Math.floor(ench.height*r));
    }

    let best={text:'',score:-1};
    for(const [cnv,lang] of tries){
      try{
        const {text, conf} = await doOCR(cnv, lang);
        const score = hangulRatio(text)*0.7 + (conf/100)*0.3;
        if(text && score>best.score) best={text,score};
      }catch(e){ console.error(e); }
    }
    return best.text;
  }

  // ====== 메인 감지 ======
  function roiRectFromInputs(w,h){
    return pct2rect(w,h,+els.gradeL.value,+els.gradeT.value,+els.gradeR.value,+els.gradeB.value);
  }

  async function detectOnce(){
    const imgData=drawFrame(); if(!imgData){ setStatus('비디오 대기'); return; }
    const w=imgData.width, h=imgData.height;
    const rectTitle=roiRectFromInputs(w,h);
    const titleCanvas=cropImageData(imgData,rectTitle);

    // OCR → 6종 라벨 강제
    const rawText = await ocrBest(titleCanvas);
    const gemLabel = parseGemLabelKOR(rawText) || '(미확인)';

    // 색상 → 3종 강제
    const H = dominantHueFromCanvas(titleCanvas);
    const colorClass = hueToClass(H) || '(미확인)';

    els.outGem.textContent   = gemLabel;
    els.outGrade.textContent = colorClass;
    els.outDbg.textContent   = `OCR:"${rawText}"  Hue:${Number.isNaN(H)?'NaN':H.toFixed(1)}°`;

    // ROI 가이드 박스
    const ctx=els.canvas.getContext('2d');
    ctx.save();
    ctx.strokeStyle='#6aa6ff'; ctx.lineWidth=2; ctx.strokeRect(rectTitle.x,rectTitle.y,rectTitle.w,rectTitle.h);
    ctx.restore();
  }

  async function loopDetect(){
    loopOn=!loopOn;
    els.btnLoop.textContent=loopOn?'연속 감지 중지':'연속 감지 시작';
    while(loopOn){ await detectOnce(); await sleep(200); }
  }

  // ====== 드래그로 ROI 설정 ======
  (function enableRoiDrag(){
    const c=els.canvas, ctx=c.getContext('2d',{willReadFrequently:true});
    let dragging=false,start={x:0,y:0},cur={x:0,y:0};
    function canvasPoint(e){ const r=c.getBoundingClientRect(); return {x:Math.round((e.clientX-r.left)*(c.width/r.width)), y:Math.round((e.clientY-r.top)*(c.height/r.height))}; }
    function getRect(){ const x1=Math.min(start.x,cur.x),y1=Math.min(start.y,cur.y),x2=Math.max(start.x,cur.x),y2=Math.max(start.y,cur.y); return {x:x1,y:y1,w:Math.max(1,x2-x1),h:Math.max(1,y2-y1)}; }
    function pxToPct(rect){ const w=c.width,h=c.height; return { l:Math.max(0,Math.min(100,(rect.x/w)*100)), t:Math.max(0,Math.min(100,(rect.y/h)*100)), r:Math.max(0,Math.min(100,((rect.x+rect.w)/w)*100)), b:Math.max(0,Math.min(100,((rect.y+rect.h)/h)*100)) }; }
    function drawPreview(){ const imgData=drawFrame(); if(!imgData) return; const r=getRect(); ctx.save(); ctx.strokeStyle='#ffcc66'; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.restore(); }
    c.addEventListener('mousedown',e=>{ if(!c.width) return; dragging=true; start=cur=canvasPoint(e); });
    c.addEventListener('mousemove',e=>{ if(!dragging) return; cur=canvasPoint(e); drawPreview(); });
    window.addEventListener('mouseup',()=>{ if(!dragging) return; dragging=false; const r=getRect(), p=pxToPct(r); els.gradeL.value=p.l|0; els.gradeT.value=p.t|0; els.gradeR.value=p.r|0; els.gradeB.value=p.b|0; detectOnce(); });
  })();

  // ====== 버튼 이벤트 ======
  els.btnStart.addEventListener('click', async ()=>{
    try{
      stream = await navigator.mediaDevices.getDisplayMedia({
        video: { width:{max:9999}, height:{max:9999}, frameRate:{ideal:60,max:60}, displaySurface:"window", logicalSurface:true },
        audio: false
      });
      els.video.srcObject = stream;
      setStatus('화면 공유 중');
    }catch(e){ console.error(e); setStatus('거부됨'); }
  });
  els.btnGrab.addEventListener('click', detectOnce);
  els.btnLoop.addEventListener('click', loopDetect);

  // ====== OpenCV 준비 상태 표시 ======
  (function waitCv(){
    if(typeof cv!=='undefined' && cv && (cv.Mat||cv.getBuildInformation)){ cv['onRuntimeInitialized']=()=>{ els.cvState.textContent='준비'; }; if(cv.Mat){ els.cvState.textContent='준비'; } }
    else setTimeout(waitCv,120);
  })();
</script>
</body>
</html>
